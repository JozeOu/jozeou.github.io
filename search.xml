<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring 笔记（三）：使用 spring 的 IOC 解决程序耦合]]></title>
    <url>%2F2019%2F05%2F18%2Fspring%2Fspring-note3%2F</url>
    <content type="text"><![CDATA[✎例子 ✎问题 一个程序过度耦合的例子：账户的业务层和持久层的依赖关系； 创建持久层接口和实现类 1234567891011121314151617/*** 账户的持久层接口*/public interface AccountDao &#123; //保存账户 void saveAccount();&#125;/*** 账户的持久层实现类*/public class AccountDaoImpl implements AccountDao &#123; @Override public void saveAccount() &#123; System.out.println("保存了账户"); &#125;&#125; 创建业务层接口和实现类 123456789101112131415161718/*** 账户的业务层接口*/public interface AccountService &#123; //保存账户（此处只是模拟，并不是真的要保存） void saveAccount();&#125;/*** 账户的业务层实现类*/public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao = new AccountDaoImpl();//此处的依赖关系有待解决 @Override public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 上述例子中账户的业务层严重依赖于持久层，造成程序过度耦合； ✎如何解决？ 使用以下方法创建 service 和 dao 对象： 需要一个配置文件来配置我们的 service 和 dao 配置的内容：唯一标识，全限定类名 (key, value) 配置文件可以是 xml 也可以是 properties 通过读取配置文件中配置的内容，反射创建对象 ✎spring 基于 XML 的配置 项目结构 在 pom.xml 文件中添加如下依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在 resources 目录下创建 xml 配置文件 bean.xml，给配置文件导入约束，参考 spring 官方文档 让 spring 管理资源，在配置文件中配置 service 和 dao 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中，Bean 在计算机英语中，有可重用组件的含义 id 属性：对象的唯一标识。 class 属性：指定要创建对象的全限定类名 --&gt; &lt;!-- 配置 service --&gt; &lt;bean id="accountService" class="com.ourzh.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt; &lt;!-- 配置 dao --&gt; &lt;bean id="accountDao" class="com.ourzh.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试配置是否成功 123456789101112131415/*** 模拟一个表现层*/public class Client &#123; public static void main(String[] args) &#123; //1.使用 ApplicationContext 接口，就是在获取 spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 bean 的 id 获取对象 AccountService aService = (AccountService) ac.getBean("accountService"); System.out.println(aService); AccountDao aDao = (AccountDao) ac.getBean("accountDao"); System.out.println(aDao); &#125;&#125; 运行后能获取对象，则配置成功]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 笔记（二）：IoC 概念详解]]></title>
    <url>%2F2019%2F05%2F17%2Fspring%2Fspring-note2%2F</url>
    <content type="text"><![CDATA[✎程序的耦合 耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过接口传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。 耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 在软件工程中， 耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是高内聚，低耦合。 ✎分类 内容耦合：当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。 标记耦合：若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。 数据耦合：模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 ✎内聚与耦合 内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 ✎例子 在实际开发中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。应该做到 编译期不依赖，运行时才依赖。 比如： 123public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao = new AccountDaoImpl();&#125; 上面的代码表示：业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。 这种编译期依赖关系，应该在我们开发中杜绝。 我们需要优化代码解决。 再比如： 早期我们的 JDBC 操作，注册驱动时，我们为什么不使用 DriverManager 的 register 方法，而是采用 Class.forName 的方式？ 123456789public static void main(String[] args) throws Exception &#123; //1.注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName("com.mysql.jdbc.Driver"); //2.获取连接 //3.获取预处理 sql 语句对象 //4.获取结果集 //5.遍历结果集&#125; 原因就是：我们的类依赖了数据库的具体驱动类（MySQL） ，如果这时候更换了数据库品牌（比如 Oracle） ，需要修改源码来更新数据库驱动。这显然不利于程序扩展和维护。 ✎解耦的思路 使用反射来创建对象，而避免使用 new 关键字； 通过读取配置文件来获取要创建的对象全限定类名。 例如： 使用 JDBC 时，是通过反射来注册驱动的，代码如下： 1Class.forName("com.mysql.jdbc.Driver"); // 此处只是一个字符串 此时的好处是，类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的） 。 同时，也产生了一个新的问题， mysql 驱动的全限定类名字符串是在 java 类中写死的（硬编码），一旦要改还是要修改源码。解决这个问题也很简单，使用配置文件配置。 ✎工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候， 让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件， 创建和获取三层对象的类就是工厂。 上述思路仍存在两个问题： 存哪去？ 分析：由于有很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。 答案：在应用加载时，创建一个 Map，用于存放三层对象。我们把这个 Map 称之为容器。 什么是工厂？ 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 原来：获取对象时，都是采用 new 的方式。 是主动的； 现在：获取对象时，是跟工厂要，然后由工厂为我们查找或者创建对象。 是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。 ✎控制反转 **控制反转（Inversion of Control，IoC）**是一种设计思想，简单说就是创建 Java 对象的过程从之前 new 出来，变成了由 Spring 工厂创建出来（由 Spring 来负责控制对象的生命周期和对象之间的关系），控制反转，转移的就是创建对象的主动权/控制权。 作用：削减计算机程序的耦合，设计出松耦合、更优良的程序。 实现原理：通过配置文件将需要创建的对象的信息进行定义，在运行时，当对象 A 需要对象 B，Spring 工厂会通过反射生成配置文件定义的类对应的对象。 ✎依赖注入 **依赖注入（Dependency Injection，DI）**是 spring 框架核心 IoC 的具体实现。即在运行时，动态地将某个依赖关系注入到程序中，从而向某个对象提供它所需要的其他对象。 IoC 和 DI 的关系：同一个概念的不同角度描述。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 笔记（一）：Spring 概述]]></title>
    <url>%2F2019%2F05%2F16%2Fspring%2Fspring-note1%2F</url>
    <content type="text"><![CDATA[✎Spring 是什么 Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control，反转控制）和 AOP（Aspect Oriented Programming，面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。 ✎Spring 的发展历程 1997 年，IBM 提出了 EJB 的思想 1998 年，SUN 制定开发标准规范 EJB1.0 1999 年， EJB1.1 发布；2001 年，EJB2.0 发布；2003 年，EJB2.1 发布；2006 年， EJB3.0 发布 Rod Johnson（spring 之父） Expert One-to-One J2EE Design and Development (2002) 阐述了 J2EE 使用 EJB 开发设计的优点及解决方案 Expert One-to-One J2EE Development without EJB (2004)，阐述了 J2EE 开发不使用 EJB 的解决方式（Spring 雏形） 2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） ✎Spring 的优势 方便解耦，简化开发：通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。让开发者从这些底层实现类的实例化、依赖关系装配等工作中脱离出来，专注于更有意义的业务逻辑开发工作。 AOP 编程的支持：通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付。 声明式事务的支持：可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试：可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架：Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接支持。 降低 JavaEE API 的使用难度：Spring 对 JavaEE API（如 JDBC、 JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。 Java 源码是经典学习范例：Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无疑是 Java 技术的最佳实践的范例。 ✎Spring 体系结构]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 详解]]></title>
    <url>%2F2019%2F05%2F16%2Fjava%2Fjdbc%2F</url>
    <content type="text"><![CDATA[✎JDBC 概述 **JDBC（Java DataBase Connectivity，java 数据库连接）**是一种用于执行 SQL 语句的 Java API。JDBC 是 Java 访问数据库的标准规范，可以为不同的关系型数据库提供统一访问，它由一组用 Java 语言编写的接口和类组成。 JDBC 需要连接驱动，驱动是两个设备要进行通信，需满足一定通信数据格式，数据格式由设备提供商规定。设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。 ✎JDBC 原理 Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。 JDBC 是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。 ✎JDBC 入门案例 ✎准备数据 12345678910111213141516171819# 创建数据库create database mydb;# 使用数据库use mydb;# 创建表create table account( id int primary key auto_increment, name varchar(20), money float);# 初始化数据insert into account(name,money)values ('aaa',1000), ('bbb',2000), ('ccc',3000); ✎添加依赖 在 Maven 项目中添加 mysql 连接依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ✎实现 注意：mysql 8 与之前版本的操作有所不同。 12345678910111213141516171819202122232425262728public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 1.注册驱动，使用反射 // Class.forName("com.mysql.jdbc.Driver"); // mysql 8 Class.forName("com.mysql.cj.jdbc.Driver"); // 2.获取连接 // String url = "jdbc://mysql://localhost:3306/mydb"; // mysql 8 String url = "jdbc:mysql://localhost:3306/mydb?useSSL=false&amp;serverTimezone=UTC"; Connection conn = DriverManager.getConnection(url,"root", "1234"); // 3.获取语句执行对象 Statement statement = conn.createStatement(); // 4.执行 SQL 语句 ResultSet rs = statement.executeQuery("select * from account"); // 5.处理结果集 while (rs.next()) &#123; // 获得一行数据 int id = rs.getInt("id"); String name = rs.getString("name"); float money = rs.getFloat("money") System.out.println(id + "." + name + " has $" + money); &#125; // 6.释放资源 rs.close(); statement.close(); conn.close();&#125; ✎API 详解 ✎注册驱动 代码：Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); JDBC 规范定义驱动接口：java.sql.Driver mysql 8 驱动包提供了实现类：com.mysql.cj.jdbc.Driver 使用 Class.forName() 加载一个使用字符串描述的驱动类。 如果使用 Class.forName() 将类加载到内存，该类的静态代码将自动执行。通过查询 com.mysql.jdbc.Driver 源码，我们发现 Driver 类“自动”将自己进行注册。 12345678910public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125; ……&#125; 另一种方法：DriverManager 工具类提供注册驱动的方法 registerDriver()，方法的形参是 java.sql.Driver，因此可以通过语句 DriverManager.registerDriver(new com.mysql.jdbc.Driver());进行注册；但不推荐使用，因为存在以下不足： 程序耦合； 硬编码，后期不易于程序扩展和维护； 驱动被注册两次。 ✎获取连接 代码：Connection conn = DriverManager.getConnection(“jdbc:mysql://localhost:3306/mydb?useSSL=false&amp;serverTimezone=UTC”, ”root”, ”1234”); 获取连接需要方法 DriverManager.getConnection(url, username, password)，三个参数分别表示： url：需要连接数据库的位置（地址） user：用户名 password：密码 ✎获取执行对象 代码：Statement statement = conn.createStatement(); ✎执行 SQL 语句 常用方法： int executeUpdate(String sql); - 执行 insert, update, delete 语句 ResultSet executeQuery(String sql); - 执行 select 语句 boolean execute(String sql); - 执行 select 语句时返回 true，执行其他的语句返回 false ✎处理结果集 ResultSet 实际上就是一张二维的表格，我们可以调用其 boolean next(); 方法指向下一行记录；再使用 T getT(int colIndex / String colLabel) 方法（列下标从1开始）来获取指定列的数据； 12rs.next(); // 指向下一行rs.getInt(1); // 获取该行第一列的整型数据 常用方法： Object getObject(int colIndex / String colLabel) - 获得任意对象 String getString(int colIndex / String colLabel) - 获得字符串 int getInt(int colIndex / String colLabel) - 获得整型 double getDouble(int colIndex / String colLabel) - 获得双精度浮点型 ✎释放资源 与 IO 流一样，使用后的资源需要关闭！关闭的顺序是 先得到的后关闭，后得到的先关闭。 ✎JDBC 工具类 对数据库进行”增删改查“都需要先”获取数据库连接“，可以封装一个工具类 JdbcUtils，提供获取连接对象的方法，从而实现代码复用。 12345678910111213141516171819202122232425public class JdbcUtils &#123; private static String driver = "com.mysql.cj.jdbc.Driver"; private static String url = "jdbc:mysql://localhost:3306/mydb?useSSL=false&amp;serverTimezone=UTC"; private static String username = "root"; private static String password = "1234"; static &#123; try &#123; // 注册驱动 Class.forName(driver); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取连接 * @return 数据库的连接 * @throws SQLException */ public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url, username, password); return conn; &#125;&#125; ✎JDBC 增删改查 1234567891011121314151617181920212223242526272829public static void main(String[] args) throws SQLException &#123; // 使用JDBC 工具类获取数据库连接 Connection conn = JdbcUtils.getConnection(); // 获取语句执行对象 Statement statement = conn.createStatement(); // 增 int r = statement.executeUpdate("insert into account(name,money) values('ddd',500)"); System.out.println("插入操作返回值：" + r); // 删 r = statement.executeUpdate("delete from account where id = 1"); System.out.println("删除操作返回值：" + r); // 改 r = statement.executeUpdate("update account set name='cat' where id = 3"); System.out.println("修改操作返回值：" + r); // 查 ResultSet rs = statement.executeQuery("select * from account where id = 3"); if(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); float money = rs.getFloat("money"); System.out.println(id + "." + name + " has $" + money); &#125; else&#123; System.out.println("没有数据"); &#125; // 释放资源 rs.close(); statement.close(); conn.close();&#125; ✎预处理对象 SQL注入问题：用户输入的内容作为了SQL语句语法的一部分，改变了原有SQL真正的意义。 例如登录案例 SQL 语句如下: 1select * from 用户表 where name=账号 and password=密码; 此时，当用户输入正确的账号与密码后，查询到了信息则让用户登录；但是当用户输入的账号为 xxx，密码为 'xxx' or 'a'='a'时，则真正执行的 SQL 语句变为： 1select * from 用户表 where name='xxx' and password='xxx' or 'a'='a'; 此时，上述查询语句 where 后条件始终为真，会查询出数据库中全部记录的，用户就直接登录成功了，这便是SQL注入问题。 如何解决？使用预处理对象 PreparedStatement PreparedStatement 处理的每条 sql 语句中所有的实际参数都必须使用占位符 ? 来替换。 1234567891011121314151617public static void main(String[] args) throws SQLException &#123; // 使用JDBC 工具类获取数据库连接 Connection conn = JdbcUtils.getConnection(); // 含占位符的 sql 语句 String sql = "update account set name=? where id=?"; // 获取预处理对象 PreparedStatement psmt = conn.prepareStatement(sql); // 设置实际参数，序号从1开始 psmt.setString(1, "dog"); psmt.setInt(2, 4); // 执行 int r = psmt.executeUpdate(); System.out.println("修改操作返回值：" + r); // 释放资源 psmt.close(); conn.close();&#125;]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP 笔记（三）：最短编辑距离]]></title>
    <url>%2F2019%2F05%2F09%2Fnlp-course-notes%2Fnlp-note3%2F</url>
    <content type="text"><![CDATA[✎知识讲解 ✎定义 如何衡量两个字符串有多相似？ 拼写纠正：用户键入“graffe”，以下哪个最接近？ graf graft grail giraffe 计算生物学： 编辑距离（Edit Distance）：两个字符串之间的最短编辑距离是指将一个字符串变换为另一个需要的编辑操作（插入(Insertion)，删除(Deletion)，替换(Substitution)）的最小数量。 例如： 如果每个操作的代价值为1，则此两个字符串之间的距离为5； 如果替换操作的代价值为2，则距离为8。 如何得到最短编辑距离？ 尝试：搜索从起始字符串到最终字符串的路径（编辑序列）： 初始状态：需转换的词语 操作：插入，删除，替换 目标状态：需得到的词语 路径代价：（即我们需尽量缩短的）编辑数量 这样，求最短编辑距离相当于搜索，但是所有编辑序列的空间很大，我们无法穷举！而且许多不同路径以相同的状态结束，因此无需跟踪所有这些路径，只需求出到最终状态的最短路径即可。 符号定义：对于两个字符串 X of length n Y of length m 我们定义 D(i, j) 为 X[1...i]（X 的前 i 个字符）和 Y[1...j]（Y 的前 j 个字符）间的编辑距离。 因此 X 和 Y 间的编辑距离为 D(n, m)。 ✎计算最短编辑距离 方法：动态规划（Dynamic Programming） ✎动态规划 对 D(n, m) 的表格计算（tabular computation），通过把原问题分解为相对简单的子问题的方式来求解； 特点：自底向上（Bottom-up） 对于较小的 i, j 计算 D(i, j) 对于较大的 i, j ，以之前的计算结果为基础得出 D(i, j)，0 &lt; i &lt; n，0 &lt; j &lt; m ✎算法实现 初始化：D(i, 0) = i，D(0, j) = j 递推关系： 终止：D(n, m) is distance ✎计算对齐的回溯 计算对齐（Computing alignments）：我们经常需要将两个字符串的每个字符彼此对齐，通过保持“回溯（backtrace）”来做到这点。 回溯得到两个字符串和它们之间的对齐： Performance： Time：O(nm) Space：O(nm) Backtrace：O(n+m) ✎加权最短编辑距离 为什么要在计算中加权？ 拼写纠正：有些字母比其他字母更容易输入错 生物学：某些类型的删除或插入更有可能发生 算法实现： ✎练习 动态规划实现求解最小编辑距离。 12345678910111213141516171819202122def minEditDistance(word1, word2): m = len(word1) + 1 n = len(word2) + 1 dp = [[0 for i in range(n)] for j in range(m)] for i in range(n): dp[0][i] = i for i in range(m): dp[i][0] = i for i in range(1, m): for j in range(1, n): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1]+2) return dp[m-1][n-1]word1 = "intention"word2 = "execution"print(minEditDistance(word1, word2))]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP 笔记（二）：基本文字处理]]></title>
    <url>%2F2019%2F05%2F06%2Fnlp-course-notes%2Fnlp-note2%2F</url>
    <content type="text"><![CDATA[✎知识讲解 ✎正则表达式 正则表达式 (Regular Expressions) 是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个规定字符串。 ✎基本语法 析取：字符集合[]，范围表示[A-Z] Pattern Matches [wW]oodchuck Woodchuck, woodchuck [1234567890] 任一数字 [A-Z] 任一大写字母 [a-z] 任一小写字母 [0-9] 任一数字 否定析取：[^Ss] (仅当&quot;^&quot;出现在字符集合模式[]的第一个字符时) Pattern Matches [^A-Z] 任一非大写字母 [^Ss] 既不是&quot;S&quot;也不是&quot;s&quot; a^b 与字段相同 其他析取：析取中的“|”，对匹配条件进行逻辑“或”运算 Pattern Matches groundhog|woodchuck groundhog 或 woodchuck a|b|c = [abc] 特殊字符：? * + . ^ $（要表示这些特殊符号本身，需要在其前加一个\进行转义） Pattern Matches ？ 匹配前面的子表达式一次或零次 * 匹配前面的子表达式任意次 + 匹配前面的子表达式一次或多次 . 匹配除&quot;\n&quot;和&quot;\r&quot;之外的任意单个字符 ^ 匹配输入字行首，如果设置了RegExp对象的Multiline属性，也匹配“\n”或“\r”之后的位置 $ 匹配输入字行尾，如果设置了RegExp对象的Multiline属性，也匹配“\n”或“\r”之前的位置 ✎举例 例子：找到文本中“the”的所有实例。 错解： [tT]he ，错误返回其他词汇，即匹配本不应被匹配的字符串（there，then，other） 错误类型：False positives（误报 Type I） the ，遗漏了大写字母开头的实例，即没有匹配到本应被匹配的字符串（The） 错误类型：False negatives（漏报 Type II） 处理错误：降低应用程序中的错误率通常涉及两种对立的工作： 提高准确性或精确度（最小化False positives） 提高覆盖率或召回度（最小化False negatives） ✎总结 正则表达式起着至关重要的作用。对于任何的文本处理来说，正则表达式通常是复杂序列的首选模型； 对于许多困难的任务，我们使用机器学习分类器，但是正则表达式将作为分类器中的特征值，在获取一般化时非常有用。 ✎字标记 ✎文本归一化 每个NLP任务都需要做文本归一化（Text Normalization）处理： 在运行文本中对单词进行分段、标记 规范字格式 在运行文本中对句子进行分段 ✎分词 问题：语言问题。不同语言差异较大，很难统一算法。 中文分词： 中文词汇是由汉字组成的，汉字通常含有一个音节和一个语素，每个词汇平均由2.4个汉字组成； 标准基线分割算法：最大匹配算法（也称贪心算法 - Greedy） ，对英语不适用 给定一个中文词汇表和一个字符串 在字符串开头启动指针 在字典中找到与从指针开始的字符串匹配的最长单词 将指针移动至越过此单词 跳至第 2 步重复此过程 ✎词语规范化 规范化 (Normalization)：信息检索需要规范化用语，索引文本 &amp; 查询字词必须有相同的格式。 大写转换 (Case folding)：由于用户倾向于使用小写字母，经常将所有字母转换为小写；对于情感分析，MT，信息提取等，字母的大小写转换是非常有帮助的。 词形还原 (Lemmatization)：将变形或变体形式转换为基本形式（如：am, are, is → be，car, cars, car’s, cars’ → car）。 语素： 构成单词的微小而有意义的单元 词干（stems）：核心含义单位 词缀（Affixes）：依附于词干上的单元，通常具有语法功能 ✎词干提取 定义：在信息检索中，将词语缩短至其词干形式。词干提取即是对词缀的粗略删减。 e.g. automate(s), automatic, automation all reduced to automat. 词干提取算法 (Porter’s algorithm) ✎句子划分与决策树 句子划分（Sentence Segmentation） ！，？是相对明确的标点符号 句号“.”的含义模糊 句子边界 缩写表示（Dr.） 数学表示（.02%） 构建二元分类器 Looks at a “.” Decides EndOfSentence / NotEndOfSentence Classifiers: hand-written rules, regular expressions, or machine-learning 决策树（Decision Tree） ，可用来确定单词是否为句子结尾。 决策树的实现： 决策树仅仅是 if-then-else 的语句，有趣的是其选择功能； 难以手动建立决策树结构：手动构建至适用于简单的特征及领域；对于数字要素，选择每个阈值太难，相反，结构通常通过机器学习从训练语料库中得出。 ✎练习 提取“hello world” 1234567import rekey = r"&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello world&lt;h1&gt;&lt;/body&gt;&lt;/html&gt;"p = r"(?&lt;=&lt;h1&gt;).+?(?=&lt;h1&gt;)"pattern = re.compile(p)matcher = re.search(pattern, key)print(matcher.group(0)) 输出：hello world 匹配第一个“python” 1234567import rekey = r"javapythonhtmlvhdlpython"p = r"python"pattern = re.compile(p)matcher = re.search(pattern, key)print(matcher) 输出：&lt;re.Match object; span=(4, 10), match='python'&gt; 找到所有一级标题 123456import rekey = r"&lt;h1&gt;hello world&lt;h1&gt;" #源文本p = r"&lt;h1&gt;.+&lt;h1&gt;" #正则表达式规则pattern = re.compile(p)print(pattern.findall(key)) 输出：['&lt;h1&gt;hello world&lt;h1&gt;'] 匹配“http://”和“https://” 123456import rekey = r"http://www.poshoaiu.com and https://iusdhbfw.com" #源文本p = r"https?://" #正则表达式规则pattern = re.compile(p)print(pattern.findall(key)) 输出：['http://', 'https://'] 多字符匹配 1234567891011import rekey1 = r"12345&lt;hTml&gt;hello&lt;/Html&gt;67890"p1 = r"&lt;[Hh][Tt][Mm][Ll]&gt;.+?&lt;/[Hh][Tt][Mm][Ll]&gt;"pattern1 = re.compile(p1)print(pattern1.findall(key1))key2 = r"mat cat pat"p2 = r"[^p]at"pattern2 = re.compile(p2)print(pattern2.findall(key2)) 输出： 12[&apos;&lt;hTml&gt;hello&lt;/Html&gt;&apos;][&apos;mat&apos;, &apos;cat&apos;]]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP 笔记（一）：介绍 NLP]]></title>
    <url>%2F2019%2F05%2F06%2Fnlp-course-notes%2Fnlp-note1%2F</url>
    <content type="text"><![CDATA[✎从语言到信息 ✎从语言中提取信息 ✎含义 从以下内容自动提取句意和结构： 人类语言文本和演讲（新闻、社交媒体等） 社交网络 基因组序列 ✎应用实例 信息检索：每天6,586,013,574次网络搜索（估算），基于文本的信息检索很可能成为当今软件中最常用的功能 ； 文本分类：对短信、新闻进行分类； 提取情绪和社会语义：很多的意思都隐藏在内涵中（内涵：除单词的字面意思或主要意义之外，由其引发的想法或感觉。），通常称提取内涵为情感分析。如对餐厅评价进行情感分析，判断差评 or 好评； 计算生物学：比较基因序列；（序列比较的关键之处：寻找基因、决定功能、揭示进化进程。这也是拼写检查的工作方式。Hint：编辑距离算法） 社交网络：由您的亲朋好友组成的网络离线或在线关系。可以计算这些网络的属性，从中提取信息。（社交关系的结构：人作为节点，链接代表关系的建立） ✎通过语言与人类交互 对话系统/聊天机器人：Siri，Google assistant，Facebook M，Cortana等 推荐系统：网易云音乐推荐，豆瓣电影、图书推荐等 问答系统 ✎NLP 概述 ✎背景 为什么语言解释难以实现？ 语言有歧义 存在非标准语言 会不断产生新词 如何在这些问题上取得进展？ 需要什么工具？ 关于语言和世界的知识 一种结合各种知识体系的方法 怎么做？ 从语言数据建立概率模型 模型与算法 正则表达式 (Regular Expressions) 编辑距离与对齐方式 词嵌入（针对词义的向量/神经网络模型） 机器学习分类器（朴素贝叶斯/线性回归/神经网络） 推荐算法（协同过滤） 网络算法 (PageRank) 语言学工具（情绪词典 – Sentiment lexicons） ✎什么是 NLP？ **自然语言处理（NLP）**是计算机科学、 人工智能、 语言学的交集领域。 NLP的目标是让计算机处理或者“理解”自然语言，从而执行譬如预约、买东西、问题回答等有用的任务。但是充分理解和表达语言的含义（甚至定义语言）是件有难度的事情。达到完美的语言理解被称为 AI-complete[1]问题。 ✎NLP 层级 ✎NLP应用 从简单到复杂 拼写检查、关键字搜索、同义词查找 从网站提取信息，如产品价格、日期、地点、人员或公司名称 分类：阅读教材，判断长文本的积极/消极的情绪 机器翻译 口语对话系统 复杂的问答系统 NLP在工业上的应用越发广泛 搜索（书面或口头上） 在线广告匹配 自动/辅助翻译 市场或财务/交易的情绪分析 语音识别 聊天机器人/对话代理：自动化客户支持、控制设备、订购货物 ✎为什么NLP是一门困难的学科？ 表现、学习和使用语言/情景/世界/视觉知识的复杂性 人类语言具有不明确性（与编程和其他正式语言不同） 人类语言的解释取决于现实世界、常识和语境知识 ✎深度学习在NLP中的应用 深度 NLP = 深度学习 + NLP 即结合自然语言处理的思想和目标，采用表示学习和深度学习的方法来解决这些问题 。 深度 NLP 在各个层级上的表示方式都为向量。 在人工智能领域，最困难的问题被非正式地称为 AI-complete 或 AI-hard。——维基百科 ↩]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning 笔记（二）：单变量线性回归]]></title>
    <url>%2F2019%2F05%2F05%2Fmachine-learning-course-notes%2Fml-note2%2F</url>
    <content type="text"><![CDATA[线性回归 (Linear regression) 是一种以线性模型来建模自变量与因变量关系的方法。 分为： 单变量线性回归 (Linear regression with one variable)：只有一个自变量； 多变量线性回归 (Linear regression with multiple variable)：有多个自变量。 本篇先从单变量线性回归入手。 ✎模型表达 (Model representation) 一个预测房价的例子： 给定某地不同面积房子的价格的数据集，希望通过该数据集构建一个模型，该模型能根据房子的面积来预测其价格。 该例子属于 有监督学习 中的 回归 问题。 使用如下标记描述回归问题： m = Number of training examples （训练样例的数量） x’s = “input” variable / features （输入变量 / 特征） y’s = “output” variable / “target” variable （输出变量 / 目标变量） (x,y) - one training example （一个训练样例） (x(i),y(i)) - ith training example （第 i 个训练样例） h (hypothesis) - hθ(x) = θ0+θ1x （学习算法的解决方案或函数，将 x’s 映射到 y’s） ✎损失函数 (Cost function) Hypothesis: hθ(x) = θ0+θ1x , 参数 θi’s 如何选择？ 情形一：假定 θ0 = 0，Cost function 变为 J(θ1) 情形二：θ0，θ1 都可变，Cost function 为 J(θ0, θ1) ✎]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning 笔记（一）：背景，应用领域，基本概念]]></title>
    <url>%2F2019%2F05%2F05%2Fmachine-learning-course-notes%2Fml-note1%2F</url>
    <content type="text"><![CDATA[人工智能、机器学习，数据挖掘，神经网络之间的关系： ✎关于课程内容 ✎实践的机器学习和数据挖掘技术 基本概念，核心工具 学习系统的框架, 优化方法, 分类, 回归, 聚类,关联规则， 链接分析 主流技术，典型实际问题的解决方法 深度神经网络， Boosting/随机森林+决策树 并行化机器学习算法（大数据下的机器学习） 应用: 搜索引擎、推荐系统、图像搜索，量化交易等 Kaggle, PASCAL VOC，腾讯社交广告预测比赛，百度快速人像 识别比赛经验分享 ✎Machine Learning Part Optimization method（优化方法） Gradient descent（梯度下降） Stochastic gradient descent（随机梯度下降） Coordinate descent（坐标下降） Regression Linear regression（线性回归） Classification（分类） Logistic Regression (Parallelization)（逻辑回归（并行化）） Boosting + decision trees, Random Forest (Parallelization) Deep Neural Networks（深度神经网络） Clustering（聚类） K-means Recommendation Systems（推荐系统） matrix factorization / field-aware factorization machines ✎Data Mining Part Association Rules Similarity Search Learning to hash Link Analysis Page Rank ✎背景 ✎软件的现状 过去十多年，我们开发的软件系统主要是收集数据 ERP系统=单据电子化 邮件系统=信件电子化 企业运作产生大量的数据 互联网的网页/图片/视频数据 互联网/移动应用中的用户行为数据 金融行情/交易数据，各种经济数据，上市公司财务数据 监控摄像头（小区，交通，商铺）或其他传感器产生的数据 医疗数据 … ✎软件的未来 从收集数据到分析数据，市场上需要“聪明”的软件 能否给我推荐我喜欢的电影/衣服/新闻/游戏/朋友？ 汽车/无人机能否自动驾驶？工业机器人能否代替工人？ 机器能否理解图片内容、视频内容、自然语言？ 机器能否代替人工决策？ … ✎工业中的机器学习 大规模数据+人工特征+线性模型为主 高质量的人工特征（特征工程）+并行化训练+高吞吐量 预测 中等规模的数据，可用非线性模型（如Boosting+决策树， 随机森林） 深度学习 在一些难以获得高质量人工特征的应用中获得巨大成功 图像/视频/语音/自然语言理解，广告点击率预估 关键技术 并行化（分布式）学习算法，内存/训练时间限制 典型场景：给你1000台机器， 10000GB数据，要求你的算法在1小时内完 成训练 高吞吐量预测 典型场景：每个CPU每秒钟要完成800-1000个预测 模型稳定性 增量训练 机器学习人才需求 Developer：负责实现并行化、高吞吐量的算法；特征工程 Researcher：设计新的机器学习算法，提升算法的效果（如准确率） ✎应用成果 微软的“同声翻译” Google 的语言机器人助手 AlphaGo 击败人类顶尖棋手 网页分类 垃圾邮件过滤 手写识别 人脸识别 搜索引擎结果排序 机器翻译 广告排序，广告推荐 相似图片搜索 相机中的人脸检测 ✎基本概念 ✎machine learning vs. data mining 机器学习：从数据中自动分析获得规律，并利用规律对未知数据进行预测 数据挖掘：“数据模型”的发现过程，即从数据中发现有用的“规律” 机器学习擅长的典型场景是人们对数据中的寻找目标（规律）几乎一无所知，例如Netflix电影推荐。但是，当挖掘的目标能够比较清楚地描述时，机器学习的方法并不成功。例如“在web上定位人们的简历”，基于规则的方法优于机器学习方法。 ✎机器学习类型 有监督学习 (Supervised Learning)：从标签化的训练数据集中推导出预测函数的过程，即对训练数据集中的每个样本，都给出对应的“正确答案”（标签 (label)）。 可根据输出变量的类型分为 分类 和 回归 两类： 分类 (classification)：离散变量预测，为定性输出； 回归 (regression)：连续变量预测，为定量输出。 无监督学习 (Unsupervised Learning)：从无标签的训练数据集中推导出预测函数的过程，即只给定训练数据集，不给结果（标签）。 聚类 (clustering)：无监督学习的方法。聚类的结果是产生一组集合，一个集合中的对象与同集合中的对象彼此相似，与其他集合中的对象相异。 半监督学习 (Semi-supervised learning)：有监督学习和无监督学习的中间带。对于半监督学习，其训练数据一部分是有标签的，另一部分没有，而且没标签的数据量一般远大于有标签的数据量（这符合现实情况）。隐藏在半监督学习下的基本规律：数据的分布必然不是完全随机的，通过一些有标签数据的局部特征，以及更多没标签数据的整体分布，就可以得到可以接受甚至是非常好的分类结果。 可根据不同的学习场景分为四大类： 半监督分类 (Semi-supervised classification)：在无标签样本的帮助下使用有标签样本进行训练，获得比只用有标签样本训练得到的分类器性能更优的分类器，弥补有标签样本的数据量不足的缺陷，其中标签取有限离散值。 半监督回归 (Semi-supervised regression)：在无标签样本的帮助下使用有标签样本进行训练，获得比只用有标签样本训练得到的回归器性能更优的回归器，弥补有标签样本的数据量不足的缺陷，其中标签取连续值。 半监督聚类 (Semi-supervised clustering)：在有标签样本的信息帮助下，获得比只用无标签的样本得到的结果更好的簇，提高聚类的精度。 半监督降维 (Semi-supervised dimensionality reduction)：在有标签的样本的信息帮助下找到高维输入数据的低维结构，同时保持原始高维数据和成对约束 (Pair-wise constraints) 的结构不变，即在高维空间中满足正约束 (Must-link constraints) 的样例在低维空间中相距很近，在高维空间中满足负约束 (Cannot-link constraints) 的样例在低维空间中距离很远。 开启 Machine Learning 学习之旅！]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 配置 Tomcat 运行 Java Web 项目]]></title>
    <url>%2F2019%2F05%2F04%2Fidea%2Fidea-add-tomcat%2F</url>
    <content type="text"><![CDATA[✎Tomcat 下载、安装 ✎下载 Tomcat 在哪下载？ Tomcat 官网，点击左侧 Download 下的对应版本 进入 Tomcat 9 下载页面，zip 是免安装版，installer 是安装版 ✎安装 Tomcat zip: 直接解压缩即可；找到目录 bin 下的 startup.bat：启动 Tomcat；shutdown.bat：关闭 Tomcat。 installer: 打开 exe 安装文件，一路 Next 即可。 ✎验证 启动 Tomcat，打开浏览器，键入 http://localhost:8080，能打开页面则表示安装成功！ ✎IDEA 配置 Tomcat Run -&gt; Edit Configurations… -&gt; Templates -&gt; Tomcat Server -&gt; Local 标注1：点击 Configure, 在弹窗中选择 Tomcat 安装目录； 标注2：当 Tomcat 启动后，idea 会按照配置的地址打开浏览器页面； 标注3：当修改 java 文件后，如何处理？选择重启服务器； 标注4：jre 选择，最好选择本地的 jdk 中的 jre。 ✎配置项目部署 点击 + 号 -&gt; Tomcat Server -&gt; Local 切换到 Deployment 选项卡，点击右边 + 号，选择 Artifact 选择要部署的项目（如果要用 Tomcat 运行多个项目，直接在这里添加即可，注意 Application context 的选择） 点击 OK，配置完成！ ✎运行 Web 项目 如下图，选中 tomcat，点击运行按钮即可自动部署项目，可以看到启动日志 部署完成后会自动打开浏览器 项目部署成功！]]></content>
      <categories>
        <category>IDEA 配置</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 上传项目到 Github]]></title>
    <url>%2F2019%2F05%2F03%2Fidea%2Fidea-add-git%2F</url>
    <content type="text"><![CDATA[环境前提：IntelliJ IDEA, Github 账号，Git 配置 ✎配置 Git 和 Github File -&gt; Setting -&gt; Version Control -&gt;Git 在 Path to Git executable 选择 git 安装后的 git.exe 文件，然后点击 Test，测试设置是否成功 File -&gt; Setting -&gt; Version Control -&gt;GitHub 点击 + 进行 Add account, 填写 Github 账号的用户名和密码，Log in ✎创建本地仓库 VCS -&gt; Import into Version Control -&gt; Create Git Repository… 在弹窗中选择项目所在的本地目录，点击 OK，此时项目文件全部变成红色 ✎上传项目到本地仓库 项目上右键 -&gt; Git -&gt; Add, 此时项目文件变成绿色（文件处于暂存区，并没有进入到版本库） 项目上右键 -&gt; Git -&gt; Commit Directory 在弹窗中输入 Commit Message，点击 commit，此时项目文件从暂存区进入版本库中，项目文件变成白色 ✎上传项目到 Github 远程仓库 VCS -&gt; Import into Version Control -&gt; Share Project on GitHub 在弹窗中输入仓库名和描述，点击 Share, 即开始在 Github 中创建远程仓库并上传项目文件（若未配置 Github, 会弹窗要求输入用户名和密码） 注意：会进行语法检查，若存在错误或警告会给出确认提示，点击 Commit 即可 上传成功后 IDEA 右下角会给出提示 查看 Github 远程仓库，项目上传成功！ ✎提交修改 项目上右键 -&gt; Git -&gt; Add, 将修改加入本地仓库暂存区 项目上右键 -&gt; Git -&gt; Commit Directory, 查看有变动的文件并输入 Commit Message, 点击 Commit and Push… 弹出 Push 框，点击 Push 查看 Github 远程仓库，提交修改成功！ ✎其他仓库操作]]></content>
      <categories>
        <category>IDEA 配置</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>idea</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 创建 Maven Web App 项目]]></title>
    <url>%2F2019%2F04%2F26%2Fidea%2Fidea-add-maven%2F</url>
    <content type="text"><![CDATA[✎安装 Maven ✎下载 Maven 在哪下载？ Maven 官网 下载完成后，将 tar.gz 压缩包解压即可。 ✎配置环境变量 老生常谈，懒得写了！ 配置完，验证： Maven 安装完成！ ✎配置 Maven 本地仓库 ✎在 IntelliJ IDEA 中配置 Maven File -&gt; Settings ✎创建 Web App 项目 以 秒杀系统 (seckill) 项目为例 Create New Project 项目创建完成！]]></content>
      <categories>
        <category>IDEA 配置</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>idea</tag>
        <tag>maven</tag>
        <tag>webapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 安装及使用教程]]></title>
    <url>%2F2019%2F04%2F21%2Fidea%2Fintellij-idea-tutorial%2F</url>
    <content type="text"><![CDATA[✎前言 IntelliJ IDEA（简称 IDEA），是 Java 语言开发的集成环境，IDEA 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、各类版本工具（Git、SVN、GitHub 等）、JUnit、CVS 整合、代码分析和创新的 GUI 设计等方面的功能都值得称道。 来开始领略 IntelliJ IDEA 的魅力吧！ ✎IDEA 安装全过程 系统环境：Windows 10 ✎下载 在哪下载？ IntelliJ IDEA 官网 在 Download IntelliJ IDEA 页面，我们可以看到 IntelliJ IDEA 分为两个版本，分别为： 旗舰版（Ultimate） 社区版（Community） 其中，旗舰版为收费版本，有 30 天试用期。社区版则是免费的，但功能较旗舰版少了很多。如果想用 IntelliJ IDEA 进行大型项目开发的的话，上旗舰版准没错。 ✎安装 双击打开 .exe 文件 软件占用空间较大，可修改安装目录，避免占用 C盘 存储空间 Options 的含义： 标注 1：表示在桌面上创建一个 IntelliJ IDEA 的快捷方式 标注 2：表示将启动器添加到环境变量中 标注 3：表示在右键菜单中添加 open folder as project 选项 标注 4：表示关联 .java、.groovy 和 .kt 文件 标注 5：表示下载和安装 JBR x86 在这里，选择默认的 JetBrains 文件夹就可以，点击 Install，进行安装： 安装完成！ ✎激活 若资金允许，请 购买正版，支持正版，人人有责 在 IntelliJ IDEA 注册码 下载破解补丁 将 破解补丁 放置到 IntelliJ IDEA 安装目录下 进入 bin 目录，找到 idea.exe.vmoptions 和 idea64.exe.vmoptions 两个文件 用文本编辑器打开这两个文件，在末尾添加 -javaagent:[破解补丁的文件路径] 保存后打开软件 在此处，选择 Darcula 黑色 UI 主题（个人喜好）并点击 Next: Default plugins，进入到默认插件配置页面： 跳过，点击 Next: Featured plugins，进入到特色插件配置页面： 跳过，点击 Start using IntelliJ IDEA，进入激活页面： 在 IntelliJ IDEA 注册码 复制注册码（该注册码一段时间后会过期，后续激活 也是找到该网站继续获取注册码填入即可），点击 OK，进入 IntelliJ IDEA 的启动界面，待进度条走完之后，就可以使用 IntelliJ IDEA 来打代码啦！ ✎使用 IDEA ✎界面详述、创建项目 打开 IntelliJ IDEA，首先迎接我们的就是这个界面： Create New Project : 创建一个新的项目； Import Project : 导入一个已有的项目，用于导入不属于 idea 模型的项目，如 Eclipse, Maven 项目； Open : 打开一个已有的项目，用于打开 idea 项目； Check out from Version Control :可以通过服务器上的项目地址 Checkout（俗称：检出） 项目。 点击 Create New Project，进入如下界面： 标注 1：IntelliJ IDEA 支持的框架及语言； 标注 2：与 标注 1 相对应的框架或语言的进一步分类。 选择 Java -&gt; Java EE，在 Project SDK 选择接下来我们的项目中所使用的 SDK（在这里是事先安装好的 JDK），然后点击 Next，进入下一步： 可以选择 Create project from template 快速创建项目 Command Line App 会自动创建一个带有main方法的类； Java Hello World 会自动创建一个带有main方法的并且会打印输出 Hello World 的类。 在这里，我们们不勾选使用模板，手工创建，直接点击 Next，进入如下界面： Project name : 项目名称（自定义，一般都小写，多个单词用下划线连接） Project location : 项目存储地址 Module name : 模块名称（默认与项目名称相同） Content root : 内容根路径 Module file location : 模块文件存储地址 Project format : 项目格式 （在 IntelliJ IDEA 中，Project 是最大单元，没有类似于 Eclipse 的工作空间（Workspace）的概念，但是我们可以在一个 Project 下创建多个 Module，默认是一个 Project 下创建一个Module，因此才出现项目名称与模块名称默认相同的现象。一般情况下，我们不需要在 More Settings 中进行修改。） 接下来，点击 Finish，完成项目的创建： （对于首次创建或打开的新项目，IntelliJ IDEA 都会创建项目索引，大型项目在创建索引的过程中可能会出现卡顿的现象，因此强烈建议在 IntelliJ IDEA 创建索引的过程中不要动项目。） 标注 1：项目结构图 标注 2：外部库 在项目结构图中，src 目录为默认的 Source root，我们一般在该目录下创建包和类；在外部库中，显示了我们导入的 JDK 1.8 版本。 编辑 Hello World 项目： 创建包：将鼠标移动到 src 目录上，然后点击右键，选择 New，再选择 Package，输入包名 demo，点击 OK; 新建类：将鼠标移动到 src 目录上，然后点击右键，选择 New，再选择 Java Class，输入类名 HelloWorld（一般情况下，如果类名出现多个单词的话，则每个单词的首字母都大写），点击 OK; 类创建完之后，在编辑区敲入代码，点击鼠标右键，选择 Run 'HelloWorld.main()'，运行。 标注 1：存放 Module 编译文件的 out 目录。 标注 2：demo包 和 HelloWorld类 标注 3：代码编辑区 标注 4：运行结果，输出&quot;Hello World!&quot; .idea：Project 的配置文件目录，配置文件以 XML 文件的形式存在，因此我们也可以通过了解这些 XML 文件来了解 IntelliJ IDEA 的相关配置。 hello_world.iml：IntelliJ IDEA 为每个 Module 自动生成的配置文件，一般情况下，我们不需要动它。 （IntelliJ IDEA 是一个没有 Ctrl + S 的 IDE，因此每次修改完代码之后，咱们只管运行或者调试即可，无需担心保存或者丢失代码的问题。） ✎使用技巧 学习慕课网课程 IntelliJ IDEA神器使用技巧，总结出的思维导图]]></content>
      <categories>
        <category>Java开发环境搭建</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>idea</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 安装 JDK 及配置环境变量]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%2Fjdk-install-tutorial%2F</url>
    <content type="text"><![CDATA[✎下载 JDK 下载地址：Oracle 官网 可能需要登录，分享一个账号，方便下载 用户名：2696671285@qq.com 密码：Oracle123 ✎安装 JDK、JRE 安装过程非常简单，首先双击打开 JDK 可执行文件 jdk-8u211-windows-x64.exe。JDK 默认安装在 C:\Program Files 目录下，可以修改安装路径，然后点击 &lt;下一步&gt;，等待安装完成即可。 JDK 安装完成后，会进入如下界面。该界面是安装与 JDK 同版本的 JRE，其实在 JDK 中已经包含 JRE 了，因此这个 JRE 实际上并没有起什么作用，安装也没有什么问题。在这里，我们选择安装，点击 &lt;下一步&gt;，等待安装完成即可。 安装完成后，会进入如下界面。如果有需要的话，点击 &lt;后续步骤&gt;，将会访问教程、API 文档和开发人员指南等内容；否则的话，直接点击 &lt;关闭&gt; 就 ojbk 啦！ ✎配置环境变量 “此电脑”右击选择“属性” -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量 -&gt; 新建 新建变量，变量名为 JAVA_HOME，变量值为 C:\Program Files\Java\jdk1.8.0_211 ( 即 JDK 安装目录 )，点击 &lt;确定&gt;，然后打开 PATH 变量进行编辑，将 ;%JAVA_HOME%\bin 追加到 PATH 变量值的最后面。 ✎验证 打开 cmd，输入 java -version 和 javac -version，结果如下图则说明 JDK 安装及环境变量配置成功。]]></content>
      <categories>
        <category>Java开发环境搭建</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 从入门到放弃]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%2Fjava-learning-history%2F</url>
    <content type="text"><![CDATA[吾日三省吾身，三次都发现自己菜得抠脚，遂决定踏上 Java 工程师的修炼之路。 路漫漫其修远兮，吾将上下而求索。 本篇将记录自己的 Java 学习历程，保持持续更新！ ✎开发环境搭建 工欲善其事，必先利其器。 ✎安装 JDK 和 JRE 参考 Win10 安装 JDK 及配置环境变量 JDK ( Java Development Kit ) : java 开发工具包，是程序员使用 java 语言编写的 java 程序所需的开发工具包，是提供给程序员使用的。JDK 包含了JRE、编译 java 源码的编译器javac、java 程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java 程序编写所需的文档和 demo 例子程序。 JRE ( Java Runtime Environment ) : java 运行时环境，包含了 java 虚拟机、java 基础类库。是使用 java 语言编写的程序运行所需要的软件环境，是提供给想运行 java 程序的用户使用的。 ✎IDE 选择与安装 My choice: IntelliJ IDEA IntelliJ IDEA（简称 IDEA），是 Java 语言开发的集成环境，IDEA 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、各类版本工具（Git、SVN、GitHub 等）、JUnit、CVS 整合、代码分析和创新的 GUI 设计等方面的功能都值得称道。 安装与使用 参考 IntelliJ IDEA 安装及使用教程 ✎入门篇 ✎Java 语法 如何学习？ Runoob 网站 网站可以让你对任意一门语言完成快速的语法门。 My method：快速浏览 Runoob 网站的 Java 教程，跟 C++ 语法对照着进行学习。（C++ 已学） ✎Java 核心技术 如何学习？ 网课：现在有很多 Java 课程，挑选一个完整地学习即可； 书：《Java 核心技术》 卷 Ⅰ 和 卷 Ⅱ，跳过一些过时的内容； 代码实践：尽量把网课和书中的代码实现一遍。 ✎初级篇]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 下 Markdown 的配置与学习]]></title>
    <url>%2F2019%2F04%2F14%2Fhexo%2Fhexo-md%2F</url>
    <content type="text"><![CDATA[本篇 更换 Hexo 下的 Markdown 渲染插件 学习 Markdown 基本语法 ✎更换 Markdown 渲染插件 ✎原因 Hexo 内置的默认渲染插件是 hexo-renderer-marked，缺少很多功能，比如 GFM (GitHub Flavored Markdown)、上下标、脚注、emoji 等 ✎hexo-renderer-markdown-it 插件 hexo-renderer-markdown-it 插件支持大量扩展功能，可以实现 Hexo 博客的 footnote 功能。 hexo-renderer-markdown-it ✎安装，配置插件 参考 Wiki 文档 先卸载原有的 hexo-renderer-marked 插件 1$ npm un hexo-renderer-marked --save 安装 hexo-renderer-markdown-it 插件 1$ npm i hexo-renderer-markdown-it --save 使用 Advanced configuration，向 站点配置文件 添加 12345678910111213141516171819202122# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: &apos;“”‘’&apos; plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup anchors: level: 2 collisionSuffix: &apos;v&apos; permalink: true permalinkClass: header-anchor permalinkSymbol: ¶ ✎Markdown 基本语法 ✎文章头基本格式 123456789---title: 如何搭建个人博客网站(二)date: 2019-04-13 23:46:39tags: - tutorial - github - hexocategories: 教程--- ✎斜体和粗体 12*斜体***粗体** 渲染效果：这是 斜体，这是 粗体 ✎分级标题 格式一： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 格式二： 123456# H1## H2### H3#### H4##### H5###### H6 ✎分割线 在单独的一行使用 *** 或者 --- 表示分割线 ✎删除线 1~~应该不经常用~~ 渲染效果：应该不经常用 ✎超链接 插入文字超链接 1[显示文字](链接地址) 插入图片 1![图片说明](图片地址) 插入音频，使用插件 hexo-tag-aplayer 1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xx%, lrc:xxx] %&#125; 具体使用方法参考：hexo-tag-aplayer 使用文档 插入视频，使用 iframe 代码 12&lt;script src=&quot;/js/youtube-autoresizer.js&quot;&gt;&lt;/script&gt;&lt;iframe width=&quot;800&quot; height=&quot;450&quot; src=&quot;视频链接&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt; ✎转义符 \ 后面的文字解析为纯文本格式，用来显示特殊符号。 例如： ## 不会解析为标题 ✎引用 使用 &gt; 来显示文字引用 渲染效果： 世界上只有一种真正的英雄主义，那就是在认识生活的真相后依然热爱生活。 ✎脚注 使用 [^1] [^1]: 的脚注对来表示（1 只是标识，用其他字符也行，但要相对应） 12Here is a footnote reference.[^note][^note]: Here is the footnote. Here is a footnote reference.[1] ✎列表与表格 ✎无序列表 使用 * + - 表示无序列表 123456+ 无序列表项 一 - 子无序列表 一 - 子无序列表 二 * 子无序列表 三+ 无序列表项 二+ 无序列表项 三 渲染效果： 无序列表项 一 子无序列表项 一 子无序列表项 二 子子无序列表项 一 无序列表项 二 无序列表项 三 ✎有序列表 使用 数字 和 . 表示有序列表 123451. 有序列表项 一 1. 子有序列表项 一 2. 子有序列表项 二2. 有序列表项 二3. 有序列表项 三 渲染效果： 有序列表项 一 子有序列表项 一 子有序列表项 二 有序列表项 二 有序列表项 三 ✎表格 绘制表格格式如下，| 控制分列，- 控制分行，: 控制对齐方式 12345| SID | Name | grade || :-- | ---: | :---: || 001 | Bob | 65 || 002 | Andy | 80 || 003 | John | 77 | 渲染效果: SID Name grade 001 Bob 65 002 Andy 80 003 John 77 ✎代码块 ✎行内代码块 使用 `codes` 表示行内代码块 ✎多行代码块 将代码块置于两个 ``` 中间（可在第一个 ``` 后面指定代码所属的编程语言） 支持多种编程语言的语法高亮的显示，行号显示 非代码示例： 1This is a code block. c++ 示例： 1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "Hello World!" &lt;&lt; endl; return 0;&#125; Here is the footnote. ↩]]></content>
      <categories>
        <category>个人博客网站搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建个人博客网站(二)]]></title>
    <url>%2F2019%2F04%2F13%2Fhexo%2Fbuild-my-website02%2F</url>
    <content type="text"><![CDATA[本篇 更换个人博客网站的主题，使 UI 更符合个人审美 开始写博客 ✎更换主题 ✎挑选你的主题 官网：Hexo Themes Github：Themes hexojs 知乎：有哪些好看的 Hexo 主题? My choice: hexo-theme-next ✎下载 Next 主题 克隆整个 hexo-theme-next 仓库 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next ✎启用主题 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 ✎验证主题 123$ hexo clean #清除Hexo缓存$ hexo g #生成静态文件$ hexo s #启动服务器 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 ✎主题设定 可以个性化设置主题的 Scheme、语言、菜单、侧栏、头像等; 具体操作参考 NexT 使用文档 最后效果： ✎写博客啦 ✎创建一个博客 1$ hexo new &apos;first-blog&apos; 此时在 username.github.io/source/_posts 目录下新建了一个 first-blog.md 的 Markdown 文件，打开 md 文件后编辑即可。 ✎编辑博客 Hexo 的博客都是用 Markdown 写的 Markdown 语法可参考我的下一篇博客：Hexo 下 Markdown 的配置与学习]]></content>
      <categories>
        <category>个人博客网站搭建</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建个人博客网站(一)]]></title>
    <url>%2F2019%2F04%2F13%2Fhexo%2Fbuild-my-website01%2F</url>
    <content type="text"><![CDATA[本篇基于 Github 和 Hexo 搭建个人博客网站。 系统：Windows 10 ✎环境前提 Node.js: 直接在官网下载安装，下载地址 Github, Git: 推荐 Github入门教程 ✎新建个人 Blog 主页的仓库 打开 Github 首页，登录后新建一个 repository, 名称为 username.github.io ( [username] 必须为 Github 账号，比如我的账号为 JozeOu, 那么仓库名必须为 jozeou.github.io) ✎使用 Hexo 创建 Blog 项目 使用 npm 安装 hexo 1$ npm install -g hexo-cli 在存放 Blog 项目的目录下 Git Bash Here, 初始化 Blog 项目 12$ hexo init username.github.io$ cd username.github.io 安装依赖包 1$ npm install 安装 Git 部署 1$ npm install hexo-deployer-git --save 本地查看 12$ hexo g #生成静态文件$ hexo s #启动服务器。默认情况下，访问网址为：http://localhost:4000/ ✎将 Blog 项目部署到 Github 复制 username.github.io 仓库的 SSH 码 编辑站点配置文件：打开 Blog 项目目录中的_config.yml 文件，把刚刚复制的 SSH 码粘贴到 repository（注意冒号后要空一格） 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 部署 1234$ hexo g #生成静态文件$ hexo d #部署或$ hexo g -d #文件生成后立即部署网站 部署成功后即可在浏览器中输入 username.github.io 访问 如何配置网站信息及 Hexo 项目文件结构解释参考 Hexo 官方文档]]></content>
      <categories>
        <category>个人博客网站搭建</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
